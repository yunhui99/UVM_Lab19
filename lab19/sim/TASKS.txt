fa/
├── fa.f            // Files list
├── fadder.sv       // Full adder module
├── fadder_if.sv    // full adder interface
├── fa_tran.sv      // Transaction class
├── fa_seq.sv       // Sequence class - parent
├── fa_seq_r.sv     // Sequence class - random child
├── fa_seq_t.sv     // Sequence class - target child
├── fa_sqr.sv       // Sequencer class
├── fa_drv.sv       // Driver class
├── fa_mon.sv       // Monitor class
├── fa_agt.sv       // Agent class
├── fa_scb.sv       // Scoreboard class
├── fa_cov.sv       // Coverage class
├── fa_env.sv       // Env class
├── fa_test.sv      // Test class
├── fa_test_r.sv    // Test class - random
├── fa_test_t.sv    // Test class - target
└── fa_tb.sv        // Testbench top

Full Adder
──────────
This is a combinational design
    // Sum calculation: a XOR b XOR cin
    assign sum = a ^ b ^ cin;
    // Carry-out calculation: (a AND b) OR (cin AND (a XOR b))
    assign cout = (a & b) | (cin & (a ^ b));

% cp ../../lab16/design/*.sv ../design
% cp ../../lab16/design/*.f ../design

% cp ../../lab14/design/bus_cov.sv ../design/fa_cov.sv
% vim ../design/fa_cov.sv
Make changes accordignly, mostly replacement
Remove all option.weight and bins
Make modifications to have these coverpoint, see below
    a_cp:
    b_cp:
    cin_cp:
    sum_cp:
    cout_cp:
    abcin_cp:
    option.comment = "THIS IS MY FA_CG COVERAGE";
      option.comment = "THIS IS MY FA_CG:A_CP COVERAGE";
      option.comment = "THIS IS MY FA_CG:B_CP COVERAGE";
      option.comment = "THIS IS MY FA_CG:CIN_CP COVERAGE";
      option.comment = "THIS IS MY FA_CG:SUM_CP COVERAGE";
      option.comment = "THIS IS MY FA_CG:COUT_CP COVERAGE";
      option.comment = "THIS IS MY FA_CG:ABCIN_CP COVERAGE";
Update the report_phase, see below
    `uvm_info("COVERAGE", $sformatf("Coverage fa_cg        : %.2f%%", fa_cg.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage a_cp         : %.2f%%", fa_cg.a_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage b_cp         : %.2f%%", fa_cg.b_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage cin_cp       : %.2f%%", fa_cg.cin_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage sum_cp       : %.2f%%", fa_cg.sum_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage cout_cp      : %.2f%%", fa_cg.cout_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage abcin_cp     : %.2f%%", fa_cg.abcin_cp.get_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage fa_cg inst   : %.2f%%", fa_cg.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage a_cp inst    : %.2f%%", fa_cg.a_cp.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage b_cp inst    : %.2f%%", fa_cg.b_cp.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage cin_cp inst  : %.2f%%", fa_cg.cin_cp.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage sum_cp inst  : %.2f%%", fa_cg.sum_cp.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage cout_cp inst : %.2f%%", fa_cg.cout_cp.get_inst_coverage()), UVM_NONE)
    `uvm_info("COVERAGE", $sformatf("Coverage abcin_cp inst: %.2f%%", fa_cg.abcin_cp.get_inst_coverage()), UVM_NONE)

% vim ../design/fadder_if.sv
Add in these right before the endinterface line, see below
  task automatic init_tb();
    a_tb = 0;
    b_tb = 0;
    cin_tb = 0;
  endtask
  initial init_tb();

% vim ../design/fa_drv.sv
Make changes accordignly, mostly replacement
Use clocking block instead of modports so that the clock skew can be tuned, see below
      @(vif.drv_cb);  // Wait for the posedge clock
      vif.drv_cb.a_tb <= tr.a;      // Drive 'a' from transaction (tr) to DUT
      vif.drv_cb.b_tb <= tr.b;      // Drive 'b' from transaction (tr) to DUT
      vif.drv_cb.cin_tb <= tr.cin;  // Drive 'cin' from transaction (tr) to DUT

% vim ../design/fa_env.sv
Add in fa_cov
Remember to update the build and connect phases

% vim ../design/fa_mon.sv
Make changes accordignly, mostly replacement
Use clocking block instead of modports so that the clock skew can be tuned, see below
    @(vif.mon_cb);
      @(vif.mon_cb);
      tr_dut = fa_tran::type_id::create("tr_dut");
      tr_dut.a = vif.mon_cb.a_tb;
      tr_dut.b = vif.mon_cb.b_tb;
      tr_dut.cin = vif.mon_cb.cin_tb;
      tr_dut.sum = vif.mon_cb.sum;
      tr_dut.cout = vif.mon_cb.cout;

% cp ../design/fa_seq.sv ../design/fa_seq_r.sv
% cp ../design/fa_seq.sv ../design/fa_seq_t.sv

% vim ../design/fa_seq_r.sv
Make changes accordignly, mostly replacement
Remove this, see below
    seq_type = "normal";
Replace the uvm_info with this, see below
    `uvm_info(get_type_name(), $sformatf("Sequence: %s", seq_type), UVM_MEDIUM)

% vim ../design/fa_seq_t.sv
Make changes accordignly, mostly replacement
Remove this, see below
    seq_type = "normal";
      seq_index++;
Replace the uvm_info with this, see below
    `uvm_info(get_type_name(), $sformatf("Sequence: %s", seq_type), UVM_MEDIUM)
Add in these before the new function line, see below
  bit [2:0] bits;
Replace with these from the repeat to the assert lines, see below
    for (seq_index = 1; seq_index <= seq_count; seq_index++) begin
      tr = fa_tran::type_id::create("tr");
      bits = seq_index - 1;
      start_item(tr);
      tr.a = bits[2]; tr.b = bits[1]; tr.cin = bits[0];
      assert(tr.a inside {0,1} && tr.b inside {0,1} && tr.cin inside {0,1})

% cp ../design/fa_tb.sv ../design/fa_tb.sv.noreg
% vim ../design/fa_tb.sv
Replace the '`include "fa_seq.sv"' line with these, see below
  `include "fa_seq_r.sv"
  `include "fa_seq_t.sv"
Add in this after fa_scb, see below
  `include "fa_cov.sv"
Add in these after fa_test, see below
  `include "fa_test_r.sv"
  `include "fa_test_t.sv"
Replace with this, see below
    run_test();

% cp ../design/fa_test.sv ../design/fa_test.sv.noreg
% cp ../design/fa_test.sv ../design/fa_test_r.sv
% cp ../design/fa_test.sv ../design/fa_test_t.sv

% vim ../design/fa_test.sv
Make changes accordignly, mostly replacement
Remove these, see below
  fa_seq seq;
  int seq_count = 10;
  int seq_min_delay = 0,  seq_max_delay = 0;
Remove the whole task

% vim ../design/fa_test_r.sv
Make changes accordignly, mostly replacement
This extends from fa_test, update the first line
Remove this, see below
  fa_env env;
Add in this after the 'int' line, see below
  string seq_type = "random";
Update the seq class to these, see below
  fa_seq_r seq;
    seq = fa_seq_r::type_id::create("seq_r");
Add in this right after the 'seq.seq_count' line, see below
    seq.seq_type = this.seq_type;
Remove the whole build phase, see below
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    env = fa_env::type_id::create("env", this);
  endfunction
Replace the uvm_info with this, see below
    `uvm_info("TEST", $sformatf("Starting %s sequences with config: count=%0d, delay=%0d-%0d",
                                seq.seq_type, seq.seq_count, seq.min_delay, seq.max_delay),
                                UVM_MEDIUM)

% vim ../design/fa_test_t.sv
Make changes accordignly, mostly replacement
This extends from fa_test, update the first line
Remove this, see below
  fa_env env;
Add in this after the 'int' line, see below
  string seq_type = "target";
Update the seq class to these, see below
  fa_seq_t seq;
    seq = fa_seq_t::type_id::create("seq_t");
Add in this right after the 'seq.seq_count' line, see below
    seq.seq_type = this.seq_type;
Remove the whole build phase, see below
  function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    env = fa_env::type_id::create("env", this);
  endfunction
Replace the uvm_info with this, see below
    `uvm_info("TEST", $sformatf("Starting %s sequences with config: count=%0d, delay=%0d-%0d",
                                seq.seq_type, seq.seq_count, seq.min_delay, seq.max_delay),
                                UVM_MEDIUM)
Change this, see below
  int seq_count = 8;

% export NR=1
% make dv
Observe STDOUT
Observe the UVM messages

% cp qrun qrun_r
% vim qrun_r
Add in this to the end of fa_simv command, see below
+UVM_TESTNAME=fa_test_r

% cp qrun qrun_t
% vim qrun_t
Add in this to the end of fa_simv command, see below
+UVM_TESTNAME=fa_test_t

% qrun_r
% qgrep

% grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff1
% diff diff1 diff1.orig
There should be no discrepency

% vim qrun_t
Comment out the first line which is the vcs command using '#'
No re-compilation is needed given there is no change to the design and uvm files

% qrun_t
% qgrep

% grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff2
% diff diff2 diff2.orig
There should be no discrepency

% grep SCORE diff1
% grep SCORE diff2
There are FAIL COUT reported by scoreboard

% verdi -ssf fa_sim.fsdb &
Load the fsdb file to check out the waveform

% vim ../design/fadder.sv
Update to the following, see below
    assign cout = (a & b) | (cin & (a ^ b));
This will fix the error reported in the scoreboard

% qrun_r
% qgrep
% grep COVER fa_sim.log > qrun_r.cov.rpt

% grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff3
% diff diff3 diff3.orig
There should be no discrepency

% grep SCORE diff3
There are zero FAIL COUT reported by scoreboard

% qrun_t
% qgrep
% grep COVER fa_sim.log > qrun_t.cov.rpt

 grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff4
% diff diff4 diff4.orig
There should be no discrepency

% grep SCORE diff4
There are zero FAIL COUT reported by scoreboard

% cp -r ../design ../design_diff_1_2_3_4
Make a backup copy in case you need to restart post diff4 steps

% cp ../design/fa_tran.sv ../design/fa_tran.sv.nofield
% vim ../design/fa_tran.sv
Remove this, see below
  `uvm_object_utils(fa_tran)
Add these before the function new, see below
  `uvm_object_utils_begin(fa_tran)
    `uvm_field_int(a, UVM_ALL_ON)
    `uvm_field_int(b, UVM_ALL_ON)
    `uvm_field_int(cin, UVM_ALL_ON)
    `uvm_field_int(sum, UVM_ALL_ON)
    `uvm_field_int(cout, UVM_ALL_ON)
    `uvm_field_int(seq_index, UVM_ALL_ON | UVM_DEC)
    `uvm_field_int(seq_count, UVM_ALL_ON | UVM_DEC)
    `uvm_field_int(tran_index, UVM_ALL_ON | UVM_DEC)
    `uvm_field_int(tran_count, UVM_ALL_ON | UVM_DEC)
    `uvm_field_string(seq_type, UVM_ALL_ON)
    `uvm_field_string(tran_type, UVM_ALL_ON)
  `uvm_object_utils_end

% cp ../design/fa_cov.sv ../design/fa_cov.sv.scov
% vim ../design/fa_cov.sv
Move the covergroup fa_cg to outside of the class fa_cov, to the first line of the file
Rename covergroup fa_cg to covergroup fa_covergroup
Add in this additional covergroup fa_tran_covergroup after covergroup fa_cg, see below
  covergroup fa_tran_covergroup with function sample(fa_tran prev_tr, fa_tran curr_tr);
    // Define the previous state as coverage points
    a_prev: coverpoint prev_tr.a { bins zero = {0}; bins one  = {1}; }
    b_prev: coverpoint prev_tr.b { bins zero = {0}; bins one  = {1}; }
    cin_prev: coverpoint prev_tr.cin { bins zero = {0}; bins one  = {1}; }

    // Define the current state as coverage points
    a_curr: coverpoint curr_tr.a { bins zero = {0}; bins one  = {1}; }
    b_curr: coverpoint curr_tr.b { bins zero = {0}; bins one  = {1}; }
    cin_curr: coverpoint curr_tr.cin { bins zero = {0}; bins one  = {1}; }

    // Cross previous and current states for each signal.
    // This creates bins for transitions like a_prev=0 -> a_curr=1.
    a_trans: cross a_prev, a_curr;
    b_trans: cross b_prev, b_curr;
    cin_trans: cross cin_prev, cin_curr;

    // Optional but powerful: Cross transitions of all three signals.
    // This has 2^3 * 2^3 = 64 bins and is very rigorous.
    all_trans: cross a_prev, b_prev, cin_prev, a_curr, b_curr, cin_curr;
  endgroup
Add in these before the function new of class fa_cov, see below
  fa_covergroup fa_cg;
  fa_tran_covergroup fa_tran_cg;

  // Variable to store the previous state
  fa_tran prev_tr;
Add in these into the function new of class fa_cov, see below
    fa_tran_cg = new();
    fa_tran_cg.set_inst_name($sformatf("%s\ (fa_tran_cg\)", get_full_name()));
Add in these before the 'endfunction' line of the function write of class fa_cov, see below
    if (prev_tr != null) begin
      fa_tran_cg.sample(prev_tr, tr);

      `uvm_info("COVERAGE", $sformatf("TR a   %0d/%0d: %0b, PREV a   %0d/%0d: %0b", tr.tran_index, tr.tran_count, tr.a, prev_tr.tran_index, prev_tr.tran_count, prev_tr.a), UVM_LOW)
      `uvm_info("COVERAGE", $sformatf("TR b   %0d/%0d: %0b, PREV b   %0d/%0d: %0b", tr.tran_index, tr.tran_count, tr.b, prev_tr.tran_index, prev_tr.tran_count, prev_tr.b), UVM_LOW)
      `uvm_info("COVERAGE", $sformatf("TR cin %0d/%0d: %0b, PREV cin %0d/%0d: %0b", tr.tran_index, tr.tran_count, tr.cin, prev_tr.tran_index, prev_tr.tran_count, prev_tr.cin), UVM_LOW)

    end
    prev_tr.copy(tr);
Add in the following build_phase after the function new of class fa_cov, see below
  virtual function void build_phase(uvm_phase phase);
    super.build_phase(phase);
    prev_tr = fa_tran::type_id::create("prev_tr");
  endfunction

% qrun_r

% grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff5
% diff diff5 diff5.orig
There should be no discrepency

% qrun_t

% grep UVM_ fa_sim.log | grep ']' | sed 's/([0-9]*)//' | sed 's/\/home.*\/lab19/lab19/' > diff6
% diff diff6 diff6.orig
There should be no discrepency

% cp qrun_r qrun_all
% vim qrun_all
Add in this to the end of fa_simv command, see below
+vcs+fsdbon +fsdbfile+fa_test_r\_sim -cm_name fa_test_r -cm_dir qrun_all
Update the -l and -assert arguments accordingly
-l fa_test_r\_sim.log
-assert report=fa_test_r\_sva.rpt
Comment out the vcs command

% grep "^fa" qrun_t >> qrun_all
% vim qrun_all
Add in this to the end of the second fa_simv command, see below
+vcs+fsdbon +fsdbfile+fa_test_t\_sim -cm_name fa_test_t -cm_dir qrun_all
Update the -l and -assert arguments accordingly
-l fa_test_t\_sim.log
-assert report=fa_test_t\_sva.rpt

% qrun_all

% urg -full64 -dir qrun_all.vdb -report fa_cov
% \ls -l `echo $ROOT/sim/fa_cov/dashboard.html`
Copy and paste the full path of dashboard.html to the web browser

% verdi -cov -covdir ./qrun_all.vdb
Alternatively the coverage results can be loaded in verdi

Data Flow Diagram
─────────────────
+----------------+       +----------------+       +----------------+       +----------------+
|                |       |                |       |                |       |                |
|   fa_test      |       |    fa_seq      |       |    fa_sqr      |       |    fa_drv      |
|   (test)       |------>|   (sequence)   |------>| (sequencer)    |------>|  (driver)      |
|                |       |                |       |                |       |                |
+----------------+       +----------------+       +----------------+       +----------------+
       |                                                           |              |
       |                                                           |              |
       v                                                           |              v
+----------------+                                          +----------------+  +----------------+
|                |                                          |                |  |                |
|   fa_env       |                                          |    fa_agt      |  |   fadder_if    |
|   (environment)|<---------------------------------------->|   (agent)      |<-| (interface)    |
|                |                                          |                |  |                |
+----------------+                                          +----------------+  +----------------+
       ^                                                                              |
       |                                                                              |
       v                                                                              v
+----------------+       +----------------+       +----------------+       +----------------+
|                |       |                |       |                |       |                |
|   fa_scb       |<------|    fa_mon      |<------|   fadder       |<------|   fa_tran      |
| (scoreboard)   |       |  (monitor)     |       | (DUT)          |       | (transaction)  |
|                |       |                |       |                |       |                |
+----------------+       +----------------+       +----------------+       +----------------+
